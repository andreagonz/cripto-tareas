%Especificacion
\documentclass[14pt]{article}

%Paquetes
\usepackage[left=2cm,right=2cm,top=3cm,bottom=3cm,letterpaper]{geometry}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
\usepackage[spanish,activeacute]{babel}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{enumerate}
%\usepackage{tabularx}
%\usepackage{wasysym}
\usepackage{graphicx}
%\graphicspath { {tarea01/media/} }
%\usepackage{pifont}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{coloremoji}
%Preambulo
\title{Criptograf√≠a y seguridad \\ Tarea 4}
\author{Andrea Itzel Gonz√°lez Vargas \\ Carlos Gerardo Acosta Hern√°ndez}
\date{Entrega: 27/04/17 \\ Facultad de Ciencias UNAM}

\titleformat*{\subsubsection}{}
\setlength\parindent{0pt}

\begin{document}
\maketitle

\subsubsection*{1. Chon Hacker est√° harto de que le llegue mucha publicidad a su correo electr√≥nico. Por esto ha decidido crear un filtro para abrir solamente los correos de sus amigos. El m√©todo consiste en lo siguiente:}
\begin{itemize}
\item Escoge dos emojis, $a$ y $b$, y se los manda a sus amigos.
\item Solo aceptar√° aquellos mensajes que inicien con una cadena $x$, donde esta cadena satisface la igualdad SHA256($a \parallel x$) = $b \parallel loquesea$.
\end{itemize}

\begin{enumerate}[label=\alph*)]
\item ¬øC√≥mo encuentras una $x$ para enviar un mensaje ¬´leg√≠timo¬ª a Chon Hacker? \\ \\
\textbf{R:} Se itera por el espacio de mensajes $m$ posibles que empiezan con $a$ (i.e. $m = a \parallel x$). Por cada uno de √©stos se obtiene el hash $h$ = SHA256($m$)  y se verifica si $h$ comienza con $b$, de no ser as√≠ se procede con el siguiente mensaje hasta que se cumpla condici√≥n.

\item ¬øEs necesario que Chon cambie $a$ y $b$ regularmente o pueden quedarse fijos? Explica. \\ \\
  \textbf{R:} Ambas opciones poseen sus respectivas desventajas. Aunque el n√∫mero de colisiones por mensaje, es el mismo para todos los mensajes, por la distribuci√≥n uniforme de los hashes, mantener
  los $emojis$ fijos no representar√≠a una vulnerabiliad significativa ante ataques del estilo de ``birthday attack''. Recordemos que se trata de cantidades absurdamente grandes de intentos para encontrar
  una colisi√≥n en un hash de 256 bits; m√°s a√∫n, la definici√≥n restrictiva del mensaje a enviar, dificulta el √©xito de estos ataques, por lo que encontrar una colisi√≥n no necesariamente derivar√≠a en la obtenci√≥n de un mensaje que pueda recibir Chon Hacker y que se abuse de tal ventaja, esto porque la restricci√≥n disminuye el espacio de mensajes posibles, por lo que una posible colisi√≥n podr√≠a corresponder
  a un mensaje fuera de ese espacio de mensajes. En este tono, de una lucha  de cientos de a√±os de procesamiento para encontrar colisiones que quiz√° no le signifiquen vulnerabilidades a nuestro amigo Chon, dudamos seriamente que un sistema de distribuci√≥n autom√°tico de correo, los autores del $spam$ que busca evitarse,
  empleen esfuerzos mucho m√°s comprometidos para asegurar que una persona en particular reciba los correos que mandan a m√∫ltiples destinatarios.\\

  Por otro lado, suponiendo que se mantienen los emojis permanentemente, un posible atacante empedernido podr√≠a obtener, mediante alguna t√©cnica que requiera menos esfuerzo y tiempo, el \textit{emoji} de seguridad y de esa forma, hacerse pasar por uno de los amigos de Chon Hacker. Una posible impostura
  podr√≠a encaminarnos a la idea de cambiarlos con cierta regularidad, establecer un tiempo de vigencia
  para los $emojis$, pero tambi√©n debe preocuparnos entonces la mec√°nica de distribuci√≥n de estos $emojis$ a los amigos de Chon Hacker, el canal de comunicaci√≥n por el que se los provee, de no considerar
  la seguridad, nos ver√≠amos en la misma situaci√≥n por la que se plante√≥ un cambio en la naturaleza temporal de los emojis. Tanto Chon como sus amigos podr√≠an ser v√≠ctimas de ataques de repetici√≥n (resultando as√≠ en m√°s $spam$ del que pudo evitarse) o quedar imposibilitado en la comunicaci√≥n, tal como en una denegaci√≥n de servicio, misma que se ten√≠a intenci√≥n de mejorar. Adem√°s, en los siguientes puntos de la tarea, ya hemos evidenciado lo impr√°ctico que resulta para un emisor, encontrar una $x$ que valide su mensaje para Chon Hacker, por lo que renovar los emojis requerir√≠a de parte de todos sus contactos una fuerte b√∫squeda de una cadena v√°lida para cada nuevo $emoji$.  \\
  
\item Estima cu√°ntas operaciones tiene que hacer alguien para enviar un mensaje. (Aplicar SHA256 cuenta como operaci√≥n b√°sica.) \\ \\
  \textbf{R:}
  Para determinar cu√°ntas operaciones es necesario realizar, debemos saber qu√© tanto del espacio de mensajes debemos explorar para encontrar una $x$ apropiada que cumpla la restricci√≥n de Chon Hacker.
  Comencemos por determinar el
  tama√±o del subconjunto de mensajes $N \subset M$ ($M$ el espacio total de mensajes), tal que $emoji_a || x \in N$. Lo consideramos un subconjunto
  propio dado que la cantidad de bits en $x$ no puede superar los $2^{64} - 32$, pues el \textit{emoji}
  que nos ha proporcionado nuestro amigo Chon Hacker para la entrada en la funci√≥n de hash toma 4 $bytes$ (32 $bits$), por tanto, la cantidad de combinaciones posibles en $N$ es menor que en $M$.\\
  
  Similarmente a \textbf{1.a)}, podemos calcular la cardinalidad del conjunto $N$ como:
  \begin{equation}
    |M| = \sum_{i = 0}^{2^{64} - 1} 2^i
  \end{equation}
  \begin{equation}
    |N| = \sum_{i = 0}^{2^{64}-32-1}2^i = \sum_{i = 0}^{2^{64}-33}2^i
  \end{equation}
  Luego, si contamos la concatenaci√≥n de $x$ con el $emoji_a$ como una de las operaciones a realizar, igualmente el c√°lculo de la funci√≥n hash y adem√°s la comparaci√≥n de los primeros cuatro $bytes$
  del resultado con el $emoji_b$, tenemos que el n√∫mero total de operaciones a realizar en el
  peor de los casos ser√°:
  \begin{equation}
    3 \cdot (|N| - 1)
  \end{equation}
  Pues se deben realizar las tres operaciones mencionadas, por cada $x$ posible. Si ninguna de
  las |N|-1 $x$ resultaron adecuadas para cumplir la condici√≥n de Chon Hacker, idealmente, deber√≠a
  encontrarse en la restante.\\
  
  A pesar de haber obtenido este resultado, no estamos del todo seguros que incluso despu√©s de este n√∫mero de operaciones encontraremos la $x$ que buscamos. Consideremos el conjunto de los mensajes tal que al aplicar la funci√≥n hash sobre ellos, resulta en las cadenas que Chon Hacker tiene planeado aceptar, i.e., $emoji_b || loquesea$, al que llamaremos $B$. Para calcular su tama√±o, consideremos primero la cardinalidad de nuestro espacio total de mensajes $M$, dividido entre el tama√±o del codominio de la funci√≥n de hash; este resultado, refiere nada m√°s que al n√∫mero de mensajes que corresponden a cada posible hash en el codominio de la funci√≥n (total de colisiones por mensaje). F√≠jemonos tambi√©n en el n√∫mero de posibles
  combinaciones existentes para $emoji_b || loquesea$, donde $loquesea$ tiene una longitud de 256-32 $bits$, pues $emoji_b$ ocupa ya 32 bits del mensaje. Al tener estos 32 $bits$ fijos, s√≥lo nos interesa
  contar la variaci√≥n en los 224 restantes, que en su total es $2^{224}$. Para cada uno de estos mensajes, existe un n√∫mero igual (pues se distribuyen uniformemente) de elementos en el codominio de la funci√≥n hash que le corresponde. El tama√±o de nuestro conjunto $B$ estar√° dado entonces por:
  \begin{equation}
    |B| = 2^{224} \cdot \frac{|M|}{2^{256}}
  \end{equation}
  Considerando el tama√±o de los conjuntos $M$, $N$ y $B$, si restamos $|M| - |B|$, obtendremos que:
  \begin{equation}
    \sum_{i = 0}^{2^{64} - 1}2^i - (2^{224} \cdot \frac{\sum_{i = 0}^{2^{64} - 1}2^i}{2^{256}}) = \sum_{i = 0}^{2^{64} - 1}2^i\cdot (1-\frac{2^{224}}{2^{256}}) = \sum_{i = 0}^{2^{64}-1}2^i\cdot (1-\frac{1}{2^{32}})
  \end{equation}
  Comparando este resultado con $|N|$, podemos ver que (5) es mayor que (2), lo que nos lleva a considerar que dentro del conjunto $M$, cabe la posibilidad de que sus subconjuntos $N$ y $B$ sean ajenos, es decir, que
  $N \cap B = \varnothing$. Hab√≠amos dicho que $B \subseteq M$ refer√≠a a los mensajes que pod√≠an llegar al conjunto de mensajes que Chon Hacker estaba dispuesto a aceptar, sin embargo $N$ refer√≠a a los
  mensajes que ten√≠amos disponibles para elegir, en caso de ser ajenos, a pesar de ejecutar todas las
  operaciones que calculamos, no encontrar√≠amos una cadena $x$ adecuada para que nuestro mensaje pueda ser recibido por nuestro receptor.
\item Haz un programa para encontrar $x$ si $a$ = üòÑ, $b$ = üòè. Cuenta las operaciones que fueron necesarias y compara con la estimaci√≥n anterior. Guarda $x$ en forma hexadecimal como texto, con los bytes separados por un espacio. \\ \\
  \textbf{R:} El programa se encuentra en el directorio \texttt{ejercicio1/}, el sistema de construcci√≥n es \texttt{apache-ant}, por lo que debe encontrarse en tal directorio las definiciones de la construcci√≥n en el archivo \textit{build.xml}.
  Para ejecutarlo, bastan los siguientes comandos:
\begin{verbatim}
    $ ant
    $ java -jar ejercicio1.jar
\end{verbatim}
  Se encontr√≥ una $x$ que cumple con las condiciones en aproximadamente 906,000,000 iteraciones (con la versi√≥n concurrente del programa del ejercicio 5). √âsto tomo al rededor de 30 min. \\
  
  F09F9884$ \parallel x$ :  F09F9884000000000000000000000000000000000000000000000000000000000000000000000000\\00000000000000000000132B418A \\
  
  SHA256(F09F9884$\parallel x$) : F09F988F901246B12CCC65512DBD25A7382A388EE50660867C8ED7508A7B8B95 \\
  
donde $a$ = F09F9884 y $b$ = F09F988F. \\

Se hicieron bastantes iteraciones, pero por suerte no se tuvo que recorrer todo el espacio de mensajes, y result√≥ ser bastante r√°pido el programa, por lo que se logr√≥ obtener el resultado en un tiempo decente. Dicha $x$ est√° almacenada en el archivo \texttt{ejercicio1/x.txt}. 
  
\item ¬øSeguir√≠a funcionando este m√©todo si ahora $b$ son dos emojis? ¬øY si $a$ son dos emojis? \\ \\
  \textbf{R:} En el primer caso, en el que $b$ son dos emojis, sucede que los hashes posibles que cumplen con la igualdad tienen sus primeros 64 bits fijos, por lo que tendremos $2^{256 - 64} = 2 ^ {192}$ hashes posibles, muchos menos que si $b$ es s√≥lo un emoji, por lo que se vuelve m√°s dif√≠cil encontrar una $x$ v√°lida y aumenta la probabilidad de que dentro de nuestro espacio de b√∫squeda de mensajes ning√∫n mensaje nos lleve a un hash deseado. \\

Si $a$ son dos emojis nuestro espacio de b√∫squeda de mensajes $x$ disminuir√° de $\sum_{i = 0}^{2^{64} - 33}2^i$ a $\sum_{i = 0}^{2^{64} - 65}2^i$, lo cu√°l reduce el n√∫mero m√°ximo de operaciones a realizar, sin embargo sigue siendo un n√∫mero muy grande para ser explorado en su totalidad en tiempo eficiente, y por tanto es peligroso ya que potencialmente podr√≠a llevarse mucho tiempo buscando una $x$ que cumpla la condici√≥n; m√°s grave a√∫n, como en el caso anterior, tambi√©n aumenta la probabilidad de no poder encontrar un hash deseado, evento que suceder√≠a si ning√∫n mensaje en el ahora reducido espacio de b√∫squeda, resulta en alg√∫n hash apropiado.

\end{enumerate}

\subsubsection*{2. El archivo \texttt{passwords-salt} contiene una lista de contrase√±as obtenidas de una base de datos. Fueron creadas usando la siguiente funci√≥n}
\begin{verbatim}
function hash(salt, password)
    hash_val = sha1(password || salt)
    return ‚Äô$‚Äô || salt || ‚Äô$‚Äô || base64(hash_val)
\end{verbatim}
Las contrase√±as originales aparecen en \texttt{common-passwords}. Encuentra cu√°les son y gu√°rdalas en un archivo\\ \texttt{passwords-salt-RESPUESTA}. \\

El programa para √©ste ejercicio (junto con \texttt{passwords-salt-RESPUESTA.txt}) est√° guardado en la carpeta \texttt{ejercicio2/}, para compilarlo se debe correr \texttt{ant} y correrlo con
\begin{verbatim}
    $ java -jar ejercicio2.jar <direcci√≥n de passwords-salt.txt> <direcci√≥n de common-passwords.txt>
\end{verbatim}

\subsubsection*{3. Obten dos programas, \texttt{bueno.py} y \texttt{malo.py}, donde el primero muestra el mensaje \texttt{"Hola mundo"}, el segundo muestra \texttt{"h0l4 mund0"}, y desde luego, ambos tienen el mismo hash MD5.}
En la carpeta \texttt{ejercicio3/}, se encuentran los archivos \texttt{bueno.py} y \texttt{malo.py}, los cu√°les deben de correrse con \textsf{python2}. Para comprobar que tienen el mismo hash MD5 se hizo el archivo \texttt{pruebamd5.py}, el cu√°l se corre con 
\begin{verbatim}
    $ python pruebamd5.py <archivo1> <archivo2>
\end{verbatim}
En este caso \texttt{<archivo1>} y \texttt{<archivo2>} ser√≠an \texttt{bueno.py} y \texttt{malo.py}.

\subsubsection*{4. AES con modos CBC y OFB}
En la carpeta \texttt{ejercicio4} correr
\begin{verbatim}
    $ python3 aes.py [c|d] [cbc|ofb} <archivoEntrada> <archivoClave>
\end{verbatim}
donde \texttt{<archivoClave>} es la llave de 16 bytes.

\subsubsection*{5. Ejercicios 1 y 2 concurrentes}
\textsf{Ejercicio 1} \\
En la carpeta \texttt{ejercicio5/chon-hacker}, compilar con \texttt{ant} y correr con
\begin{verbatim}
    $ java -jar chon-hacker.jar <num de hilos> <semilla>
\end{verbatim}
donde \texttt{<num de hilos>} es el n√∫mero de hilos a usar y \texttt{<semilla>} es la semilla del generador pseudoaleatorio. \\

\textsf{Ejercicio 2} \\
En la carpeta \texttt{ejercicio5/passwords}, compilar con \texttt{ant} y correr con
\begin{verbatim}
    $ java -jar passwords.jar <direcci√≥n de passwords-salt.txt> <direcci√≥n de common-passwords.txt> 
    <N√∫m de hilos>
\end{verbatim}
donde \texttt{<N√∫m de hilos>} es el n√∫mero de hilos a usar.
\end{document}
\grid
